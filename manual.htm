<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>manual</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 17pt; }
 .s2 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 17pt; }
 .a, a { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .p, p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; margin:0pt; }
 h1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .s4 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s5 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s6 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 3pt; }
 .s7 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -3pt; }
 .s8 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s9 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 4.5pt; vertical-align: -1pt; }
 .s10 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s11 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s12 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s13 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -2pt; }
 .s14 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 5pt; }
 .s15 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s16 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 3pt; }
 .s17 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s18 { color: black; font-family:Arial-BoldItalicMT, sans-serif; font-style: italic; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s19 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 3pt; }
 .s20 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s21 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -2pt; }
 .s22 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -3pt; }
 .s23 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -3pt; }
 .s24 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s25 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s26 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s27 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s28 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s29 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .s30 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -3pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 0; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: center;">SNEG</p><p class="s2" style="padding-top: 2pt;padding-left: 13pt;text-indent: 0pt;line-height: 112%;text-align: center;">Mathematica package for calculations with non-commuting operators of the second quantization algebra</p><p class="s1" style="padding-left: 13pt;text-indent: 0pt;text-align: center;">MANUAL</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 13pt;text-indent: 0pt;text-align: center;"><a href="mailto:rok.zitko@ijs.si" class="a" target="_blank">Copyright (C) 2006 Rok Zitko, </a><a href="mailto:o@ijs.si" class="a" target="_blank">rok.zitk</a><a href="mailto:o@ijs.si" target="_blank">o@ijs.si</a></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><ol id="l2"><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Introduction</h1><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The purpose of this manual is to describe the notations and conventions used in the SNEG library. The manual is rather abstract and concise, it focuses more on the design of the library than on real-world examples; it is not a tutorial. The examples in directory examples/ should thus be studied in conjunction with reading this text. For details, one should consult the library source code, which is the only true reference.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Non-commuting multiplication</h1><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The cornerstone of SNEG is the non-commuting multiplication function nc. <i>Mathematica</i>’s built-in mul- tiplication function Times has Orderless attribute, which corresponds to the mathematical property of commutativity, therefore it is unsuitable. Another built-in function, NonCommutativeMultiply, has Flat attribute, which corresponds to the mathematical property of associativity. Non-commuting multi- plication should indeed be associative; unfortunately, Flat attribute also affects pattern matching, which proved to be undesirable for our purposes due to decreased computational performance.</p><p class="s5" style="text-indent: 0pt;line-height: 7pt;text-align: left;">↑ ↓</p><p style="text-indent: 0pt;text-align: left;"/><p class="s6" style="padding-left: 5pt;text-indent: 14pt;line-height: 94%;text-align: justify;"><span class="p">An operator string is a sequence of second-quantization operators, such as </span><span class="s4">c</span>†<span class="s7">k   </span><span class="s8">c</span>†<span class="s7">k   </span><span class="s8">c</span><span class="s9">k</span><span class="s10">↓</span><span class="s4">c</span><span class="s11">k</span><span class="s10">↑</span><span class="p">.  In SNEG, it would be represented as nc[c[CR,k,UP],  c[CR,k,DO],  c[AN,k,DO],  c[AN,k,UP]] (see Section 0.3 on operators).</span></p><p style="padding-left: 20pt;text-indent: 0pt;text-align: justify;">Function nc has the following basic properties:</p><ul id="l3"><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">Associativity: for example, nc[<i>a, </i>nc[<i>b, c</i>]] = nc[<i>a, b, c</i>], where <i>a</i>, <i>b </i>and <i>c </i>are operators.</p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: justify;">Linearity: for example, nc[<i>αa </i>+ <i>βb, c</i>] = <i>α</i>nc[<i>a, c</i>] + <i>β</i>nc[<i>b, c</i>], where <i>α </i>and <i>β </i>are numbers, and <i>a</i>, <i>b </i>and <i>c </i>are operators. Linearity implies distributivity. Furthermore, numerical objects are factored out from operator strings.</p></li><li><p style="padding-top: 6pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">Product of zero terms equals one, nc[] = 1.</p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">Product of one term equals the term itself, nc[<i>a</i>] = <i>a</i>.</p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 14pt;text-align: justify;">In addition, fermionic operators are automatically normal ordered by anti-commuting the creation op- erators to the left and annihilation operators to the right using the default (canonical) or user-defined anti-commutation relations (see Section 0.5 on anti-commutation relations and operator ordering). This produces equivalent results for equivalent strings of operators and enables automatic expression simplifi- cations. This property is the nc equivalent of argument sorting in the commuting multiplication function Times.</p><p style="padding-left: 6pt;text-indent: 14pt;text-align: justify;">Dirac bras and kets (see Section 0.8 on Dirac notation) can also appear in nc multiplication expressions. They are automatically shifted to the right-most side of operator expressions. The default behavior is that bras and kets commute with operators, i.e. it is assumed that they belong to a different Hilbert space than the one where the second quantization operators operate.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Operators</h1><p style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: right;">In SNEG, operators are indexed objects, for example c[t, sigma]. The expression head, c, is the oper- ator name, while t, sigma are indeces which indicate, for example, if the operator is a creation or an an- nihilation operator, and the associated degrees of freedom such as spin. The operator character of c must be declared using the snegfermionoperators function: for example snegfermionoprators[c].</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: justify;">By convention, the first index indicates if the operator creates or annihilates a particle. Two constants are predefined for this purpose: CR=0 and AN=1. Another convention is that the spin index in the case of <i>S </i>= 1<i>/</i>2 operators is on the last position. For convenience, two further constants are predefined: UP=1 and DO=0.</p><p style="padding-left: 6pt;text-indent: 14pt;text-align: justify;">For a single orbital, the creation operators are thus c[CR, UP] and c[CR, DO], while the corre- sponding annihilation operators are c[AN, UP] and c[AN, DO]. (Conjugation can be performed using the function conj.)</p><p class="s4" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">0.4.  NUMBERS AND NUMERIC EXPRESSIONS                                                                               <span class="p">3</span></p></li><li><h1 style="padding-top: 12pt;padding-left: 38pt;text-indent: -32pt;text-align: left;">Numbers and numeric expressions</h1><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">SNEG must be able to differentiate operators from numbers and other numeric expressions in order to fac- tor out non-operator parts of operator expressions. Using snegrealconstants[x1,  x2,.    ], x1,</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">x,. are defined to be real constants (invariant under conjugation). Using snegcomplexconstants[z1,</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">z2,...], z1, z2,. . . are defined to be complex constants. Finally, using snegfreeindexes[k, sigma,...] we notify SNEG that k, sigma,. . . are indexes: this is required to factor out numerical expressions such as KroneckerDelta[k1,k2] out of operator strings.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Anti-commutation relations and operator ordering</h1><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Two properties of operators must be known to SNEG to perform automatic reorderings and simplifications. These are anti-commutation relations and the vacuum state. The first affects how the transpositions of operators are performed, while the latter determines the conventional ordering of operators in operator strings.</p><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">{ }</p><p style="text-indent: 0pt;text-align: left;"/><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">{   }                                    { }</p><p style="text-indent: 0pt;text-align: left;"/><p class="s12" style="padding-left: 5pt;text-indent: 14pt;text-align: left;"><span class="p">The default anti-commutation relation for fermionic operators are the usual cannonical anti-commutation relations, </span>{<span class="s4">c</span><span class="s6">†</span><span class="s13">α</span><span class="s8">, c</span><span class="s9">β</span>} <span class="p">=  </span><span class="s4">δ</span><span class="s11">αβ</span><span class="p">, </span>{<span class="s4">c</span><span class="s6">†</span><span class="s13">α</span><span class="s8">, c</span><span class="s7">β</span><span class="s14">† </span>} <span class="p">=  0, and </span>{<span class="s4">c</span><span class="s11">α</span><span class="s4">, c</span><span class="s11">β</span>} <span class="p">=  0.  Operators with different heads simply anti- commute. The value of the   </span><span class="s4">c</span><span class="s6">†</span><span class="s13">α</span><span class="s8">, c</span><span class="s9">β</span><span class="s8">   </span><span class="p">anti-commutator is defined by the funciton acmt[c,    indexes1  , indexes2  .  The default behaviour is to literally compare indexes1 and indexes2:  1 is returned if they are equal, and 0 otherwise.</span></p><p style="padding-left: 20pt;text-indent: 0pt;text-align: left;">ordering[c]=SEA, ordering[c]=EMPTY.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Expression-building functions</h1><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">SNEG includes several functions that can be used to build operator expressions such as occupation number, spin operator, spin-spin scalar product, charge-charge repulsion, etc.</p><p class="s15" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Σ</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 6pt;text-indent: 14pt;text-align: justify;">Unless otherwise specified, parameters to such functions are operators with their type (CR or AN) and spin indeces removed, for example c[]. To build the occupancy (number) operator for orbital <i>c</i>, we there- fore call number[c[]], which returns an expression equivalent to     <span class="s7">σ </span><i>c</i><span class="s6">†</span><span class="s13">σ</span><i>c</i><i>σ</i>.  The sum over spin is au-</p><p class="s15" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Σ</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">tomatically performed. Additional indexes are given as arguments to c[], for example number[c[k]]</p><p class="s4" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 86%;text-align: justify;"><span class="p">gives an expression corresponding to </span><span class="s7">σ </span>c<span class="s16">d</span>ag<span class="s11">kσ</span>c<span class="s11">kσ</span><span class="p">, i.e. the occupancy operator for a state with wavenum- ber </span>k<span class="p">.</span></p><p style="padding-left: 20pt;text-indent: 0pt;text-align: justify;">Functions in this group are:</p><ul id="l4"><li><p class="s4" style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;"><span class="p">number[c[],  sigma] - number of particles with spin sigma in orbital </span>c<span class="p">, i.e. </span>n<span class="s11">σ</span> <span class="p">= </span>c<span class="s6">†</span><span class="s13">σ</span><span class="s8">c</span><span class="s9">σ</span><span class="p">.</span></p><p class="s15" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Σ</p><p style="text-indent: 0pt;text-align: left;"/></li><li><p style="padding-top: 6pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">number[c[]] - charge density (number of particles), i.e. <i>n </i>= <i>n</i><span class="s10">↑</span><span class="s17"> </span>+ <i>n</i><span class="s10">↓</span>.</p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;line-height: 13pt;text-align: left;">spinx[c[]], spiny[c[]], spinz[c[]] - spin density, i.e. <b>S </b>=     <span class="s7">αβ </span><i>c</i><span class="s6">†</span><span class="s13">α</span>(1<i>/</i>2<span class="s18">σ</span>)<i>c</i><i>β</i>, where <i>α</i></p><p style="padding-left: 30pt;text-indent: 0pt;line-height: 11pt;text-align: left;">and <i>β </i>are spin indexes and <span class="s18">σ </span>is the vector of Pauli matrices.</p></li><li><p class="s4" style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;"><span class="p">spinplus[c[]] and spinminus[c[]] - spin raising and spin lowering operators, </span>S<span class="s19">+</span><span class="s15"> </span><span class="p">= </span>S<span class="s11">x</span> <span class="p">+ </span>IS<span class="s11">y</span> <span class="p">and </span>S<span class="s6">−</span><span class="s17"> </span><span class="p">= </span>S<span class="s11">x</span> <span class="s12">− </span>IS<span class="s11">y</span><span class="p">.</span></p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">spinss[c[]] - the total spin operator squared, <b>S</b><span class="s19">2</span>.</p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">spinspin[c[1], c[2]] - scalar product of two spin operators for different (or equal) orbitals,</p><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">·</p><p style="text-indent: 0pt;text-align: left;"/><h2 style="padding-left: 30pt;text-indent: 0pt;text-align: left;">S<span class="s20">1</span><span class="s15"> </span>S<span class="s20">2</span><span class="p">. Transverse and longitudinal parts of the scalar product are obtained using spinspinxy[c[1], c[2]] and spinspinz[c[1], c[2]].</span></h2></li><li><p class="s4" style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;text-align: left;"><span class="p">hubbard[c[]] - Hubbard’s local electron-electron repulstion operator, </span>n<span class="s10">↑</span>n<span class="s10">↓</span><span class="p">.</span></p><p class="s5" style="text-indent: 0pt;line-height: 7pt;text-align: left;">↑</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Σ</p><p style="text-indent: 0pt;text-align: left;"/></li><li><p style="padding-top: 9pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">nambu[c[]] - Nambu spinor, <i>η </i>= <span class="s12">{</span><i>c</i><span class="s6">†</span><span class="s17"> </span><i>, </i>(<span class="s12">−</span>1)<i>n</i><i>c</i><span class="s10">↓</span><span class="s12">}</span>.</p></li><li><p style="padding-top: 7pt;padding-left: 30pt;text-indent: -8pt;line-height: 13pt;text-align: left;">isospin[c[]] - isospin operator, <b>I </b>=    <span class="s7">αβ </span><i>η</i><i>α</i>(1<i>/</i>2<span class="s18">σ</span>)<i>η</i><i>β</i>, where <i>η </i>is the Nambu spinor, <i>α </i>and <i>β</i></p><p style="padding-left: 30pt;text-indent: 0pt;line-height: 11pt;text-align: left;">are isospin indexes and <span class="s18">σ </span>is the vector of Pauli matrices.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">4</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Σ</p><p style="text-indent: 0pt;text-align: left;"/></li><li><p style="padding-left: 30pt;text-indent: -8pt;text-align: left;">hop[c[1],  c[2]] - electron hopping operator     <span class="s7">σ </span>(<i>c</i><span class="s6">†</span><span class="s21">1</span><span class="s13">σ</span><i>c</i><span class="s20">2</span><i>σ</i><i> </i>+ <i>c</i><span class="s6">†</span><span class="s21">2</span><span class="s13">σ</span><i>c</i><span class="s20">1</span><i>σ</i>).</p></li><li><p class="s4" style="padding-top: 8pt;padding-left: 30pt;text-indent: -8pt;text-align: left;"><span class="p">twohop[c[1],  c[2]] - two-electron hopping operator </span>c<span class="s6">†</span><span class="s22">1</span><span class="s23">↓</span>c<span class="s6">†</span><span class="s22">1</span><span class="s23">↑</span>c<span class="s20">2</span><span class="s10">↓</span>c<span class="s20">2</span><span class="s10">↑</span><span class="s17"> </span><span class="p">+ H.c..</span></p></li><li><p style="padding-top: 6pt;padding-left: 30pt;text-indent: -8pt;text-align: left;">projection[c[], pr] - projection operator. pr = PROJ0 | PROJUP | PROJDO | PROJ2</p><p class="s4" style="padding-left: 30pt;text-indent: 0pt;text-align: justify;"><span class="p">| PROJ1 | PROJ02; PROJ0 projects to zero-occupancy states, (1 </span><span class="s12">− </span>n<span class="s10">↑</span><span class="p">)(1 </span><span class="s12">− </span>n<span class="s10">↓</span><span class="p">), PROJUP to spin-up states, </span>n<span class="s10">↑</span><span class="p">(1 </span><span class="s12">− </span>n<span class="s10">↓</span><span class="p">), PROJDO to spin-down states, </span>n<span class="s10">↓</span><span class="p">(1 </span><span class="s12">− </span>n<span class="s10">↑</span><span class="p">), PROJ2 to double-occupancy states, </span>n<span class="s10">↑</span>n<span class="s10">↓</span><span class="p">, PROJ1 to single-occupancy states, and PROJ02 to zero- and double-occupancy states.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><h1 style="padding-top: 5pt;padding-left: 38pt;text-indent: -32pt;text-align: left;">Expression manipulation functions</h1><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Function invertspin inverts the spins of all operators appearing in an expression. The convention that the spin index appears at the last position must be followed.</p><p style="padding-left: 20pt;text-indent: 0pt;text-align: left;">Function conj calculates the Hermitian conjugate of an expression.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: left;">Function vev calculates the vacuum expectation value of an operator expression; vevwick does the same using Wick’s theorem.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: left;">Function wick writes an operator string using normal ordered strings of operators and contractions (Wick’s theorem).</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: left;">komutator[a,b] calculates the commutator [<i>a, b</i>], while antikomutator[a,b] calculates the the anti-commutator <span class="s12">{</span><i>a, b</i><span class="s12">}</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 38pt;text-indent: -32pt;text-align: left;">Dirac’s bra and ket notation</h1><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">⟨   |    | ⟩</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Dirac’s bras  <i>i, j, . . .   </i>and kets  <i>i, j,   </i>are represented by expressions bra[i,j,...] and ket[i,j,...], where i, j,. . . denote the quantum numbers that determine the corresponding state.</p><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">⟨     |</p><p style="text-indent: 0pt;text-align: left;"/><p class="s4" style="padding-left: 20pt;text-indent: 0pt;text-align: left;"><span class="p">By default, the values of brakets are determined using the Kronecker’s delta, i.e. </span>i<span class="s20">1</span>, j<span class="s20">1</span>, . . . i<span class="s20">2</span>, j<span class="s20">2</span>, . . . <span class="p">=</span></p><p class="s26" style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s24">δ</span><span class="s25">i</span>1<span class="s27">i</span>2 <span class="s24">δ</span><span class="s25">j</span>1<span class="s27">j</span>2 <span class="s24">. . .</span><span class="s28">.</span></p><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">| ⟩⟨ |</p><p style="text-indent: 0pt;text-align: left;"/><p class="s12" style="text-indent: 0pt;line-height: 10pt;text-align: left;">⟨ | ⟩</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 14pt;text-align: left;">Bras and kets may appear in nc strings. They do not commute, i.e. the braket <i>i j </i>is different from the projector <i>j i </i>.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: left;">Different quantum numbers correspond to different argument positions. Null placeholders can be used in place of unspecified quantum numbers. Neighboring bras and kets are “concatenated” if they have com-</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">patible patterns of Null placeholders. For example: nc[ket[i, Null], ket[Null,j]]=ket[i,j]. From the mathematical point of view, this corresponds to a direct (tensor) product of states.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s29" style="padding-left: 38pt;text-indent: -32pt;text-align: left;">VACUUM <b>vector</b></p><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Keyword VACUUM corresponds to a vacuum state. By default, if an annihilation operator is applied to VACUUM from the left, the result is 0. Correspondingly, if a creation operator is applied to conj[VACUUM] from the right, the result is 0.</p><p style="padding-left: 20pt;text-indent: 0pt;text-align: left;">By definition, nc[conj[VACUUM], VACUUM]=1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 45pt;text-indent: -39pt;text-align: left;">State vectors: operator and occupation number representations</h1><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A state can be represented either as the effect of string of creation operators on a (unspecified) vacuum state, or as a set of occupation numbers. If the vacuum is known, a one-to-one mapping between the two representations can be established.</p><p style="padding-left: 20pt;text-indent: 0pt;line-height: 11pt;text-align: left;">In  the  creati<span class="s30">√</span>o<u>n</u>  operator  representation,  a  state  is  just  an  operator  expression.   For  example,  a  one-</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">particle state 1<i>/   </i>2(<i>c</i><span class="s6">†</span><span class="s22">1</span><span class="s23">↑ </span>+ <i>c</i><span class="s6">†</span><span class="s22">2</span><span class="s23">↑</span>)<span class="s12">|</span>0<span class="s12">⟩ </span>would be described as 1/Sqrt[2]  (c[CR,1,UP]+c[CR,2,UP]),</p><p class="s5" style="text-indent: 0pt;line-height: 7pt;text-align: left;">↑ ↓</p><p style="text-indent: 0pt;text-align: left;"/><p class="s4" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="p">a two-particle state </span>c<span class="s6">†</span><span class="s22">1  </span>c<span class="s6">†</span><span class="s22">1    </span><span class="p">as nc[c[CR,1,UP],  c[CR,1,DO]], etc.</span></p><p style="padding-left: 20pt;text-indent: 0pt;line-height: 11pt;text-align: left;">In the occupation number representation, a state is given by a vector of occupation numbers, vc[0,1,0,0,1,0,...].</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Each position in the vector corresponds to some orbital with a given spin.</p><p class="s4" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">0.11.  BASIS SETS                                                                                                                                 <span class="p">5</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="text-indent: 0pt;line-height: 7pt;text-align: left;">↑                             ↓                             ↑                                    ↓</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 6pt;text-indent: 14pt;line-height: 12pt;text-align: justify;">A mapping between operators and positions in the vector is established using makebasis function. For two orbitals, for example, the mapping is defined by makebasis[c[1],  c[2]].  Position 1 then corresponds to <i>c</i><span class="s6">†</span><span class="s22">1  </span>, position 2 to <i>c</i><span class="s6">†</span><span class="s22">1  </span>, position 3 to <i>c</i><span class="s6">†</span><span class="s22">2  </span>, and position 4 to <i>c</i><span class="s6">†</span><span class="s22">2  </span>. The mapping can be accessed as the global variable BASIS, or using op2ndx and ndx2op mapping functions.</p><p style="padding-left: 6pt;text-indent: 14pt;text-align: justify;">The zero-particle vacuum can be obtained using vacuum. Operator expressions can be applied to occupation number vectors using ap. One can go from creation operator representation to occupation number representation and back using ops2vc and vc2ops mapping functions.</p><p style="padding-left: 20pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Scalar products of vectors are given by scalarproductop[a,b] and scalarproductvc[a,b].</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Norms can be calculated using normop[a] and normvc[a].</p><p style="padding-left: 6pt;text-indent: 14pt;text-align: justify;">An operator given by a second-quantisation operator expression O can be transformed using matrixrepresentationop l] and matrixrepresentationvc[O, l] to its matrix representation in a subspace spanned by</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">states given in a list l.</p><p style="padding-left: 20pt;text-indent: 0pt;text-align: justify;">A vector can be decomposed in a given subspace using decomposeop[v, l] and decomposevc[v,</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">l].</p><p style="padding-left: 20pt;text-indent: 0pt;text-align: left;">A set of vectors can be orthogonalized in a given subspace using orthogop[vs, l] and orthogvc[vs,</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">l], where vs are the vectors and l is a list of vectors spanning the subspace.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 45pt;text-indent: -39pt;text-align: left;">Basis sets</h1><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In SNEG, basis sets are lists of subspace basis sets. A subspace basis set consists of a list of invariant quantum numbers that characterize the invariant subspace and a list of states in either creation operator or occupation number representation.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: justify;">Function qszbasis[l] constructs a basis set with subspaces with well-defined charge, <i>Q</i>, and spin projection, <i>S</i><i>z</i>, quantum numbers. List l is the list of operators that defined the orbitals; it is usually the same list as the one passed as the argument to makebasis.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: justify;">Function qsbasis[l] constructs a basis set with subspaces with well-defined charge, <i>Q</i>, and total spin, <i>S</i>, quantum numbers.</p><p style="padding-left: 5pt;text-indent: 14pt;text-align: justify;">Conversions of basis sets from creation operator to occupation number representation can be performed using bzvc2bzop and bzop2bzvc functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-left: 45pt;text-indent: -39pt;text-align: left;">Symbolic sums</h1></li></ol></ol><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">sum[expr,  <span class="s12">{</span>k,  sigma,...<span class="s12">}</span>]</p></body></html>
